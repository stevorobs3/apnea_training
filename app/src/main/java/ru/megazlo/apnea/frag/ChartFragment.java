package ru.megazlo.apnea.frag;

import android.app.Fragment;
import android.view.MotionEvent;
import android.view.View;
import android.widget.Toast;

import org.androidannotations.annotations.*;
import org.androidannotations.annotations.res.ColorRes;

import java.util.*;

import lecho.lib.hellocharts.formatter.AxisValueFormatter;
import lecho.lib.hellocharts.gesture.ZoomType;
import lecho.lib.hellocharts.listener.DummyLineChartOnValueSelectListener;
import lecho.lib.hellocharts.listener.ViewportChangeListener;
import lecho.lib.hellocharts.model.*;
import lecho.lib.hellocharts.view.LineChartView;
import lecho.lib.hellocharts.view.PreviewLineChartView;
import ru.megazlo.apnea.R;
import ru.megazlo.apnea.component.Utils;

/** Created by iGurkin on 10.10.2016. */
@EFragment(R.layout.chart_fragment)
public class ChartFragment extends Fragment implements FabClickListener {

	@ViewById(R.id.chart_spo)
	LineChartView chartSpo;
	@ViewById(R.id.chart_heart)
	LineChartView chartHeart;
	@ViewById(R.id.chart_preview)
	PreviewLineChartView chartPreview;

	@ColorRes(R.color.chart_spo)
	int colorSpo;
	@ColorRes(R.color.chart_pulse)
	int colorPulse;

	@AfterViews
	void afterView() {
		final Line l1 = createLine(colorSpo, valuesSpo());

		chartSpo.setLineChartData(createData(getString(R.string.axis_spo), l1));

		/*chartSpo.setOnTouchListener((view, mEv) -> {
			//Toast.makeText(ChartFragment.this.getActivity(), "Value: " + (int)mEv.getAxisValue(MotionEvent.AXIS_Y), Toast.LENGTH_SHORT).show();
			return false;
		});*/
		/*chartSpo.setOnValueTouchListener(new DummyLineChartOnValueSelectListener(){
			@Override
			public void onValueSelected(int lineIndex, int pointIndex, PointValue value) {
				Toast.makeText(ChartFragment.this.getActivity(), "Value: " + value.getY(), Toast.LENGTH_SHORT).show();
			}
		});*/

		//chartSpo.selectValue(new SelectedValue(0, 22, SelectedValue.SelectedValueType.COLUMN));

		final Line l2 = createLine(colorPulse, valuesPulse());
		chartHeart.setLineChartData(createData(getString(R.string.axis_pulse), l2));

		chartPreview.setLineChartData(createData(getString(R.string.axis_indicators), l1, l2));
		//chartPreview.setLineChartData(data);
		chartPreview.setZoomType(ZoomType.HORIZONTAL);
		chartPreview.setViewportChangeListener(new ViewportListener());
		previewX();
	}

	float[] valuesSpo() {
		int seconds = 3 * 60 + 10;//3:10
		float[] rez = new float[seconds];
		int min = 56;
		int max = 99;
		for (int i = 0; i < rez.length; i++) {
			rez[i] = max - ((max - min) * (i / (float) seconds));
		}
		return rez;
	}

	float[] valuesPulse() {
		int seconds = 3 * 60 + 10;//3:10
		Random r = new Random();
		float[] rez = new float[seconds];
		for (int i = 0; i < rez.length; i++) {
			final int fade = 40 - Math.min(i, 40);
			int min = 50 + fade;// расчитываем min и max чтоб был нормальный коридор. падение 40 сек
			int max = 60 + fade;
			rez[i] = r.nextInt(max - min) + min;
		}
		return rez;
	}

	LineChartData createData(String title, Line... lines) {
		final LineChartData data = new LineChartData();
		data.setLines(Arrays.asList(lines));
		data.setBaseValue(0);
		Axis axisX = new Axis().setName(getString(R.string.axis_time)).setFormatter(new TimeAxisValueFormatter());
		Axis axisY = new Axis().setName(title).setHasLines(true);
		data.setAxisXBottom(axisX);
		data.setAxisYLeft(axisY);
		return data;
	}

	private void previewX() {
		Viewport vprt = new Viewport(chartPreview.getMaximumViewport());
		float dx = vprt.width() / 2.3f;
		vprt.inset(dx, 0);
		vprt.offsetTo(0, vprt.top);
		chartPreview.setCurrentViewport(vprt);
		chartPreview.setZoomType(ZoomType.HORIZONTAL);
	}

	private class ViewportListener implements ViewportChangeListener {

		@Override
		public void onViewportChanged(Viewport newViewport) {
			// don't use animation, it is unnecessary when using preview chart.
			chartSpo.setCurrentViewport(newViewport);
			chartHeart.setCurrentViewport(newViewport);
		}
	}

	private Line createLine(int color, float... vals) {
		final ArrayList<PointValue> values = new ArrayList<>();
		for (int i = 0; i < vals.length; i++) {
			values.add(new PointValue(i, vals[i]));
		}
		return new Line(values).setColor(color).setCubic(true)/*.setPointRadius(1)*/.setHasPoints(false).setStrokeWidth(1);
	}

	@Override
	public void clickByContext(View view) {
	}

	@Override
	public void modifyToContext(View view) {
		view.setVisibility(View.GONE);
	}

	@Override
	public boolean backPressed() {
		return true;
	}

	private class TimeAxisValueFormatter implements AxisValueFormatter {

		@Override
		public int formatValueForManualAxis(char[] formattedValue, AxisValue axisValue) {
			return 0;
		}

		@Override
		public int formatValueForAutoGeneratedAxis(char[] formattedValue, float value, int autoDecimalDigits) {
			char[] arr = Utils.formatMS((int) value).toCharArray();
			System.arraycopy(arr, 0, formattedValue, formattedValue.length - arr.length, arr.length);
			return formattedValue.length;
		}
	}
}
